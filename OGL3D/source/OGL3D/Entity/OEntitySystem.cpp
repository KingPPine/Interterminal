#include <OGL3D/Entity/OEntitySystem.h>
#include <OGL3D/Entity/OEntity.h>
#include <OGL3D/Game/OGame.h>
#include <OGL3D/Graphics/OGraphicsEngine.h>
#include <OGL3D/Graphics/OShaderAttribute.h>

OEntitySystem::OEntitySystem() //constructor
{
	lightShaderAttribList = {};
}

OEntitySystem::OEntitySystem(OGame* game) : OEntitySystem()
{
	m_game = game;
}

OEntitySystem::~OEntitySystem() //destructor
{
}

OGraphicsEngine* OEntitySystem::getGraphicsEngine()
{
	return m_game->getGraphicsEngine();
}

OWindow* OEntitySystem::getWindowDisplay()
{
	return m_game->getWindowDisplay();
}

short OEntitySystem::addDirectionalLight()
{
	if (directionalLightCount == 0) //if we're adding the first directional light, create the uniform for the shader
		addLightShaderAttribute(std::string("total_directional_lights"), (directionalLightCount + 1)); //short + int = int
	else
		updateLightShaderAttribute(std::string("total_directional_lights"), (directionalLightCount + 1));

	short returnIndex = directionalLightCount++; //gets the count of directional lights before it increments, which the entity can use as its index for all the light shader attributes
	return returnIndex; //return the index that the new directional light should use
}

short OEntitySystem::addPointLight()
{
	if (pointLightCount == 0) //if we're adding the first point light, create the uniform for the shader
		addLightShaderAttribute(std::string("total_point_lights"), (pointLightCount + 1)); //short + int = int
	else
		updateLightShaderAttribute(std::string("total_point_lights"), (pointLightCount + 1));

	short returnIndex = pointLightCount++; //gets the count of point lights before it increments, which the entity can use as its index for all the light shader attributes
	return returnIndex; //return the index that the new point light should use
}

short OEntitySystem::addSpotLight()
{
	if (spotLightCount == 0) //if we're adding the first spot light, create the uniform for the shader
		addLightShaderAttribute(std::string("total_spot_lights"), (spotLightCount + 1)); //short + int = int
	else
		updateLightShaderAttribute(std::string("total_spot_lights"), (spotLightCount + 1));

	short returnIndex = spotLightCount++; //gets the count of spot lights before it increments, which the entity can use as its index for all the light shader attributes
	return returnIndex; //return the index that the new spot light should use
}

short OEntitySystem::getDirectionalLightCount()
{
	return directionalLightCount;
}

short OEntitySystem::getPointLightCount()
{
	return pointLightCount;
}

short OEntitySystem::getSpotLightCount()
{
	return spotLightCount;
}

void OEntitySystem::addLightShaderAttribute(std::string attribName, std::any data)
{
	lightShaderAttribList.push_back(new OShaderAttribute(attribName, data));
}

void OEntitySystem::updateLightShaderAttribute(std::string attribName, std::any data)
{
	for (OShaderAttribute* shaderAttribute : lightShaderAttribList)
	{
		if (shaderAttribute->attribName == attribName) //compares the strings of the char pointers
		{
			shaderAttribute->data = data;
			return; //break out of the function since there should only be one attribute of each name
		}
	}
}

void OEntitySystem::passLightShaderAtrributes(std::list<OShaderAttribute*>* p_entityAttribList)
{
	for (OShaderAttribute* shaderAttribute : lightShaderAttribList)
	{
		p_entityAttribList->push_back(shaderAttribute);
	}
}

bool OEntitySystem::createEntityInternal(OEntity* entity, size_t id) //adds the entity to our map
{
	auto ptr = std::unique_ptr<OEntity>(entity); //generate a unique pointer for the entity
	m_entities[id].emplace(entity, std::move(ptr)); //std::move allows the transfor of resources. moves our pointer into the map, and ties it to the entity

	entity->m_id = id; //provides the entity its id, so that it can call back to this system
	entity->m_entitySystem = this; //sets a pointer to this system so that it can be easily referenced

	entity->onCreate(); //calls the onCreate of the entity.

	return true; //confirm this was successful
}

void OEntitySystem::removeEntity(OEntity* entity) //add to the set of entities to be destroyed so that it can happen at the beginning of the update() method
{
	m_entitiesToDestroy.emplace(entity);
}

void OEntitySystem::update(float deltaTime) //update method
{
	for (auto e : m_entitiesToDestroy) // for each entity to destroy
	{
		m_entities[e->m_id].erase(e); //erase it from the m_entities map.
		//TODO: One thing to note is that this erases the entity, but keeps the id entry in the map. So the map size will never reduce. Could this be optimized?
	}
	m_entitiesToDestroy.clear(); //clear out the set of entities to destroy

	for (auto&& [id, entities] : m_entities) //for the remaining valid entities.
	{
		for (auto&& [ptr, entity] : entities) //this is some crazy syntax - I need to look into this
		{
			//for the first frame of the game, pass all the lighting that was generated by creating the objects.
			//TODO: Improve this by keeping track of shader attributes that were just created in a separate list, and pass these attributes to the objects.
			//TODO: once that's done, move the pointer from the "newly created" list to the normal lighting attributes list.
			//TODO: Also think about making this safe through the OEntity "passLightShaderAtrributes" function, to ensure no duplicate values get pushed into the entity.
			if (firstFrame)
			{
				entity->passLightShaderAtrributes();
			}

			entity->onUpdate(deltaTime); //update the entity
		}
	}

	if (firstFrame) firstFrame = false; //after the first frame is over
}

void OEntitySystem::draw()
{
	for (auto&& [id, entities] : m_entities) //for the remaining valid entities.
	{
		for (auto&& [ptr, entity] : entities) //this is some crazy syntax - I need to look into this
		{
			entity->onDraw(); //update the entity
		}
	}
}
